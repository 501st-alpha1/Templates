<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <UsingTask
        TaskName="GetDotNetPackageFolder"
        TaskFactory="CodeTaskFactory"
        AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.v4.0.dll" >
        <ParameterGroup>
            <PackageFolderPath ParameterType="Microsoft.Build.Framework.ITaskItem" Output="true" />
        </ParameterGroup>
        <Task>
            <Using Namespace="System" />
            <Using Namespace="Microsoft.Build.Framework" />
            <Using Namespace="Microsoft.Build.Utilities" />
            <Code Type="Fragment" Language="cs">
                <![CDATA[
                try
                {
                    string runtimeRoot = ".dnx";
                    string userProfile = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
                    var packageFolder = Path.Combine(userProfile, ".dnx","packages");
                    PackageFolderPath = new TaskItem(packageFolder);
                }
                catch(Exception ex)
                {
                    Log.LogError("Error getting Package folder");
                    Log.LogErrorFromException(ex);
                }
                
                return !Log.HasLoggedErrors;
                ]]>
            </Code>
        </Task>
    </UsingTask>    


    <UsingTask
        TaskName="GetDependencyListForTemplates"
        TaskFactory="CodeTaskFactory"
        AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.v4.0.dll" >
        <ParameterGroup>
            <DependencyList ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="True"/>
            <MergedDependencyList ParameterType="System.String" Required="True" />
            <ExternalReferencePackages ParameterType="System.String" Required="True"/>
            <TemplatePackagesList ParameterType="System.String" />
            <PackageSourcePath ParameterType="System.String" />
            <WarnOnMissingPackage ParameterType="System.Boolean"/>
        </ParameterGroup>
        <Task>
            <Using Namespace="System" />
            <Using Namespace="System.Collections.Generic" />
            <Using Namespace="System.IO" />
            <Using Namespace="System.Linq" />
            <Using Namespace="Microsoft.Build.Framework" />
            <Using Namespace="Microsoft.Build.Utilities" />
            <Code Type="Fragment" Language="cs">
                <![CDATA[
                try
                {  
                    List<string> packages = new List<string>();
                    List<string> excludedPackages = new List<string>();
                    
                    foreach(var list in DependencyList)
                    {
                        string fileName = list.ItemSpec;
                        Log.LogMessage("Opening {0}", fileName);
                        bool foundPackageReferences = false;

                        using (var file = File.OpenText(fileName))
                        {
                            while (!file.EndOfStream)
                            {
                                string line = file.ReadLine().Trim();
                                
                                if (!foundPackageReferences)
                                {
                                    if (line.StartsWith("Package references:"))
                                    {
                                        foundPackageReferences = true;
                                    }
                                    continue;
                                }
                                
                                string[] parts = line.StartsWith("*") ? line.Substring(1).Trim().Split() : line.Trim().Split();
                                string packageName = parts[0].Trim();
                                
                                if (parts.Length < 2)
                                {
                                    foundPackageReferences = false;
                                }
                                else
                                {
                                    string packageVersion = parts[1].Trim();
                                    string packageToAdd = string.Format("{0}.{1}.nupkg", packageName, packageVersion);
                                    string originalPackageToAdd = packageToAdd;
                                    string originalPackageVersion = string.Empty;
                                    bool isRTM = false;
                                    int attempt = 0;
                                    while (attempt++ < 2)
                                    {
                                        if (packageToAdd.StartsWith("*"))
                                        {
                                            packageToAdd = packageToAdd.Substring(1);
                                        }
                                        
                                        if (packages.Contains(packageToAdd))
                                        {
                                            if (attempt == 2)
                                            {
                                                Log.LogMessage("      Matched {0}", packageToAdd);
                                            }
                                            break;
                                        }
                                        else 
                                        {
                                            Log.LogMessage("  Found {0}", packageToAdd);
                                            
                                            var files = Directory.EnumerateFiles(PackageSourcePath, packageToAdd);

                                            if (!ExternalReferencePackages.Contains(packageName) && files.Count() == 0)
                                            {
                                                // if there is a package dependency on another version, we should try to see if we have another version we are already including.
                                                if (attempt < 2)
                                                {
                                                    bool isOriginalNoSemVer = false;
                                                    bool isOriginalNoTimeStamp = false;
                                                    string[] originalParts = null;
                                                    var index = packageToAdd.IndexOf("-");
                                                    if (index == -1)
                                                    {
                                                        index =  packageToAdd.IndexOf(".nupkg");
                                                        isOriginalNoSemVer  = true;
                                                    }
                                                    else
                                                    {
                                                        originalPackageVersion = packageToAdd.Substring(index + 1).Replace(".nupkg", "");
                                                        var i = originalPackageVersion.IndexOf("-");
                                                        if (i == -1)
                                                        {
                                                            isOriginalNoTimeStamp  = true;
                                                        }
                                                        originalParts = originalPackageVersion.Split('-');
                                                    }
                                                    
                                                    var packageNameNoSemVer = packageToAdd.Substring(0, index);
                                                    if (isOriginalNoSemVer)
                                                    {
                                                        Log.LogError("{0} not found in coherence build", originalPackageToAdd);
                                                        break;
                                                    }
                                                        
                                                    files = Directory.EnumerateFiles(PackageSourcePath, packageNameNoSemVer + "*");
                                                    if (files.Count() > 0)
                                                    {
                                                        FileInfo info = new FileInfo(files.ToArray()[0]);
                                                        packageToAdd = info.Name;
                                                        index = packageToAdd.IndexOf("-");
                                                        var foundVersion = String.Empty;
                                                        bool isFoundNoTimeStamp = false;
                                                        string[] foundParts = null;
                                                        
                                                        if (index != -1)
                                                        {
                                                            foundVersion = packageToAdd.Substring(index + 1).Replace(".nupkg", "");
                                                            var i = foundVersion.IndexOf("-");
                                                            if (i == -1)
                                                            {
                                                                isFoundNoTimeStamp  = true;
                                                            }
                                                            
                                                            foundParts = foundVersion.Split('-');
                                                        
                                                            if (isOriginalNoTimeStamp != isFoundNoTimeStamp)
                                                            {
                                                                Log.LogWarning("Mismatched timestamp builds {0} was requested, but {1} was found.", originalPackageToAdd, packageToAdd);
                                                            }
                                                            else
                                                            {
                                                                if (foundParts[0] != originalParts[0])
                                                                {
                                                                    Log.LogWarning("{0} had a referenced semantic version of {1}, but only {2} could be found.", packageNameNoSemVer, originalParts[0], foundParts[0]);
                                                                }
                                                                else
                                                                {
                                                                    if (String.Compare(foundParts[1], originalParts[1]) < 0)
                                                                    {
                                                                        Log.LogError("{0} was referenced with version {1}-{2}, but only a lower version, {1}-{3} could be found.", packageNameNoSemVer, originalParts[0], originalParts[1], foundParts[1]);
									break;
                                                                    }
                                                                    else
                                                                    {
									Log.LogWarning("{0} was referenced with version {1}-{2} but a higher version, {1}-{3} was found.", packageNameNoSemVer, originalParts[0], originalParts[1], foundParts[1]);
                                                                        continue;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                if (WarnOnMissingPackage)
                                                {
                                                    Log.LogWarning("    {0} contains {1}, but no matching package could be found on package share.", fileName, packageName);
                                                    break; 
                                                }                                             
                                                else
                                                {
                                                    Log.LogError("    {0} contains {1}, but no matching package could be found on package share.", fileName, packageName); 
                                                    break;
                                                }                                             
                                            }
                                            else
                                            {
                                                Log.LogMessage("    Adding {0}", packageToAdd);
                                                packages.Add(packageToAdd);
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    
                    if (!string.IsNullOrEmpty(TemplatePackagesList))
                    {
                        Log.LogMessage("Opening {0}", TemplatePackagesList);
                        using (var packageReference = File.OpenText(TemplatePackagesList))
                        {
                            while (!packageReference.EndOfStream)
                            {
                                string line = packageReference.ReadLine();
                                string packageName = line.Substring(1);
                                if (line.StartsWith("+"))
                                {
                                    var files = Directory.EnumerateFiles(PackageSourcePath, packageName);
                                    if (files.Count() == 0)
                                    {
                                        Log.LogWarning("  {0} contains {1}, but no matching package could be found on package share.", TemplatePackagesList, packageName);
                                    }
                                    foreach(var file in files)
                                    {
                                        FileInfo info = new FileInfo(file);
                                        Log.LogMessage("  Found {0}", info.Name);

                                        if (!excludedPackages.Contains(info.Name))
                                        {
                                            if (packages.Contains(info.Name))
                                            {
                                                Log.LogWarning("    Wildcard entry found but it is already explictly referenced. Consider removing from wildcard list.");
                                            }
                                            else
                                            {
                                                Log.LogMessage("    Adding {0}", info.Name);
                                                packages.Add(info.Name);
                                            }                               
                                        }
                                        else
                                        {
                                            Log.LogMessage("    Package excluded, skipping");
                                        }
                                    }
                                }
                                else if (line.StartsWith("-"))
                                {
                                    var files = Directory.EnumerateFiles(PackageSourcePath, packageName);
                                    if (files.Count() > 0)
                                    {                                 
                                        foreach(var file in files)
                                        {
                                            FileInfo info = new FileInfo(file);

                                            excludedPackages.Add(info.Name);
                                            if (packages.Contains(info.Name))
                                            {
                                                packages.Remove(info.Name);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        excludedPackages.Add(packageName);
                                        if (packages.Contains(packageName))
                                        {
                                            packages.Remove(packageName);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    

                    Log.LogMessage("Writing {0}", MergedDependencyList);

                    using (var outFile = System.IO.File.CreateText(MergedDependencyList))
                    {
                        foreach (var package in packages.Distinct())
                        {
                            outFile.WriteLine(package);
                        }
                        outFile.Flush();
                    }
                }
                catch(Exception ex)
                {
                    Log.LogError("Error Generating Dependency List");
                    Log.LogErrorFromException(ex);
                }
                
                return !Log.HasLoggedErrors;
                ]]>
            </Code>
        </Task>
    </UsingTask>    
    <UsingTask
        TaskName="VerifyWhitespace"
        TaskFactory="CodeTaskFactory"
        AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.v4.0.dll" >
        <ParameterGroup>
            <FileList ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="True"/>
        </ParameterGroup>
        <Task>
            <Using Namespace="System" />
            <Using Namespace="System.Collections.Generic" />
            <Using Namespace="System.IO" />
            <Using Namespace="System.Linq" />
            <Using Namespace="Microsoft.Build.Framework" />
            <Using Namespace="Microsoft.Build.Utilities" />
            <Code Type="Fragment" Language="cs">
                <![CDATA[
                try
                {   foreach(var taskItem in FileList)
                    {
                        using(var file = File.OpenText(taskItem.ItemSpec))
                        {
                            int lineNumber = 0;
                            string line = String.Empty;
                            while(!file.EndOfStream)
                            {
                                lineNumber++;
                                line = file.ReadLine();
                                if (!line.TrimEnd().Equals(line))
                                {
                                    Log.LogError("Trailing whitespace found in {0} line {1}, '{2}'", taskItem.ItemSpec, lineNumber, line);
                                }
                                if (line.Contains('\t'))
                                {
                                    Log.LogError("Embedded Tab found in {0} line {1}, '{2}'", taskItem.ItemSpec, lineNumber, line.Replace("\\t", "\\\\t"));
                                }
                            }
                            file.DiscardBufferedData();
                            file.BaseStream.Seek(-3, SeekOrigin.End);
                            if (file.Read() == 10 || file.Read() != 13 || file.Read() != 10)
                            {
                                Log.LogError("Last line in a file must be a non-blank line terminated with \\r\\n: {0} line {1}, '{2}'", taskItem.ItemSpec, lineNumber, line);
                            }
                        }
                    }
                }
                catch(Exception ex)
                {
                    Log.LogError("Error Verifying Whitespace");
                    Log.LogErrorFromException(ex);
                }
                return !Log.HasLoggedErrors;
                ]]>
            </Code>
        </Task>
    </UsingTask>
    <UsingTask
        TaskName="VerifyUsings"
        TaskFactory="CodeTaskFactory"
        AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.v4.0.dll" >
        <ParameterGroup>
            <FileList ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="True"/>
            <RequiredUsings ParameterType="System.String" Required="True"/>
        </ParameterGroup>
        <Task>
            <Using Namespace="System" />
            <Using Namespace="System.Collections.Generic" />
            <Using Namespace="System.IO" />
            <Using Namespace="System.Linq" />
            <Using Namespace="Microsoft.Build.Framework" />
            <Using Namespace="Microsoft.Build.Utilities" />
            <Code Type="Fragment" Language="cs">
                <![CDATA[
                try
                {   foreach(var taskItem in FileList)
                    {
                        String[] reqUsings = RequiredUsings.Split(';');
                    
                        bool[] hasUsing = new bool[reqUsings.Length];
                        using(var file = File.OpenText(taskItem.ItemSpec))
                        {
                            while(!file.EndOfStream)
                            {
                                string line = file.ReadLine();
                                if (line.Contains("{"))
                                {
                                    // continue to the first open brace, then go to the next file.
                                    break;
                                }
                                
                                for(int i=0; i < reqUsings.Length; i++)
                                {
                                    if (line.Contains(String.Format("using {0};", reqUsings[i])))
                                    {
                                        hasUsing[i] = true;
                                    }
                                }
                            }
                            for (int i=0; i < reqUsings.Length; i++)
                            {
                                if (!hasUsing[i]) 
                                {
                                    Log.LogError("File {0} is missing required using statement: {1}", taskItem.ItemSpec, reqUsings[i]);
                                }
                            } 
                        }
                    }
                }
                catch(Exception ex)
                {
                    Log.LogError("Error Verifying Using statements");
                    Log.LogErrorFromException(ex);
                }
                return !Log.HasLoggedErrors;
                ]]>
            </Code>
        </Task>
    </UsingTask>
</Project>